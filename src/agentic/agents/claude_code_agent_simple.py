"""
Claude Code Agent - Simplified Version

This version removes all the unnecessary config management and lets Claude Code
handle its own internal state, just like it does when running in multiple terminals.
"""
import asyncio
import json
import logging
import os
import subprocess
import tempfile
import uuid
from pathlib import Path
from typing import Dict, List, Optional, Any

from rich.console import Console

from agentic.models.agent import Agent, AgentConfig, AgentCapability, AgentType, AgentSession
from agentic.models.task import Task, TaskResult

console = Console()

# Global lock for Claude Code initialization to prevent concurrent setup wizards
_claude_init_lock = asyncio.Lock()


class ClaudeCodeAgent(Agent):
    """Simplified agent that lets Claude Code manage its own state."""
    
    def __init__(self, config: AgentConfig):
        super().__init__(config)
        self.logger = logging.getLogger(__name__)
        self.process: Optional[subprocess.Popen] = None
        self.temp_files: List[Path] = []
        
        # Enhanced Claude Code settings
        self.claude_model = config.ai_model_config.get('model', 'sonnet')
        self.session_id: Optional[str] = None
        self.memory_initialized = False
        
        self.project_root = config.workspace_path
    
    def get_capabilities(self) -> AgentCapability:
        """Return enhanced agent capabilities."""
        return AgentCapability(
            agent_type=AgentType.CLAUDE_CODE,
            specializations=[
                "coding", "refactoring", "analysis", "debugging", 
                "code_review", "architecture", "documentation", "git_operations",
                "testing", "project_management", "extended_thinking"
            ],
            supported_languages=[
                "python", "javascript", "typescript", "rust", "go",
                "java", "cpp", "c", "html", "css", "sql", "bash", "yaml", "json"
            ],
            max_context_tokens=200000,  # Claude has large context
            concurrent_tasks=100,  # Unlimited parallelism for swarm execution
            reasoning_capability=True,
            file_editing_capability=True,
            code_execution_capability=True,
            memory_capability=True,
            session_persistence=True,
            git_integration=True
        )
    
    async def health_check(self) -> bool:
        """Check if Claude Code CLI is healthy and responsive."""
        try:
            process = await asyncio.create_subprocess_exec(
                "claude", "--help",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                self.logger.debug("Claude Code CLI health check passed")
                return True
            else:
                self.logger.error(f"Claude Code CLI health check failed: {stderr.decode()}")
                return False
                
        except FileNotFoundError:
            self.logger.error("Claude Code CLI not found - install with: npm install -g @anthropic-ai/claude-code")
            return False
        except Exception as e:
            self.logger.error(f"Claude Code CLI health check error: {e}")
            return False
    
    async def start(self) -> bool:
        """Start the enhanced Claude Code agent session."""
        try:
            # Check health first
            if not await self.health_check():
                return False
            
            # Initialize project memory if needed
            await self._ensure_memory_setup()
            
            # Create session
            self.session = AgentSession(
                agent_config=self.config,
                workspace=self.project_root,
                status="starting"
            )
            
            # Change to project directory
            os.chdir(self.project_root)
            
            # Generate session ID for persistence
            self.session_id = str(uuid.uuid4())
            
            self.session.mark_active()
            self.logger.info(f"Enhanced Claude Code agent {self.config.name} started with session {self.session_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start Claude Code agent: {e}")
            if self.session:
                self.session.mark_error(str(e))
            return False

    async def _ensure_memory_setup(self) -> None:
        """Ensure CLAUDE.md memory files are properly set up."""
        try:
            project_memory = self.project_root / "CLAUDE.md"
            
            if not project_memory.exists():
                self.logger.info("Creating CLAUDE.md with default template")
                
                memory_content = f"""# {self.project_root.name} - Claude Code Memory

> **Note**: This file was auto-generated by Agentic's Claude Code agent.
> You can customize it for your project. Add it to .gitignore to keep preferences local.
> See examples/claude_memory_template.md for a comprehensive template.

## Project Overview
This project uses Agentic's Claude Code integration for AI-powered development tasks.

## Basic Guidelines
- **Code Quality**: Write clean, maintainable code
- **Type Safety**: Use type hints where applicable
- **Documentation**: Document complex logic and public APIs
- **Testing**: Include tests for new functionality
- **Consistency**: Follow existing patterns in the codebase

## AI Assistant Instructions
- Always consider the full project context before making changes
- Follow the existing code style and conventions
- Prefer safe, incremental improvements
- Explain your reasoning for significant changes

## Personal Notes
<!-- Add your personal preferences and project-specific instructions here -->
"""
                
                project_memory.write_text(memory_content)
                self.logger.info(f"Created default memory at {project_memory}")
                self.logger.info("ðŸ’¡ Tip: Customize CLAUDE.md for your project and add it to .gitignore")
                self.logger.info("ðŸ’¡ See examples/claude_memory_template.md for a comprehensive template")
            else:
                self.logger.debug(f"Memory file already exists at {project_memory}")
            
            self.memory_initialized = True
            
        except Exception as e:
            self.logger.warning(f"Failed to setup memory: {e}")
    
    async def stop(self) -> bool:
        """Stop the Claude Code agent session."""
        try:
            # Cleanup any running processes
            if self.process and self.process.poll() is None:
                self.process.terminate()
                try:
                    self.process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.process.kill()
            
            # Cleanup temporary files
            for temp_file in self.temp_files:
                try:
                    temp_file.unlink()
                except Exception:
                    pass
            
            self.temp_files.clear()
            
            if self.session:
                self.session.status = "stopped"
            
            self.logger.info(f"Claude Code agent {self.config.name} stopped")
            return True
            
        except Exception as e:
            self.logger.error(f"Error stopping Claude Code agent: {e}")
            return False
    
    async def execute_task(self, task: Task) -> TaskResult:
        """Execute a task using Claude Code CLI"""
        try:
            # Determine optimal execution mode based on task characteristics
            execution_mode = self._determine_execution_mode(task)
            
            # Build Claude Code command
            cmd = self._build_claude_command(task, execution_mode)
            
            self.logger.info(f"Executing {execution_mode} task: {task.command[:50]}...")
            self.logger.debug(f"Full command: {' '.join(cmd)}")
            self.logger.debug(f"Working directory: {self.workspace_path}")
            
            # Set up environment with API keys
            env = os.environ.copy()
            self._set_environment_variables(env)
            
            # Execute Claude Code
            result = await self._execute_claude_command(cmd, env, task, execution_mode)
            
            return result
            
        except Exception as e:
            self.logger.error(f"Task execution failed: {e}")
            return TaskResult(
                task_id=task.id,
                status="failed",
                error=str(e),
                agent_id=self.session.id if self.session else "unknown"
            )
    
    def _determine_execution_mode(self, task: Task) -> str:
        """Determine optimal execution mode based on task characteristics"""
        command_lower = task.command.lower()
        
        # Quick analysis tasks â†’ print mode for fast results
        quick_tasks = [
            'explain', 'analyze', 'what does', 'how does', 'describe',
            'summarize', 'review', 'debug', 'find', 'check'
        ]
        
        # File creation tasks â†’ print mode with explicit file creation prompts
        file_creation_tasks = [
            'create', 'write', 'build', 'implement', 'generate'
        ]
        
        # Interactive tasks â†’ interactive mode for iterative work only
        interactive_tasks = [
            'help me', 'work with me', 'iterative', 'step by step',
            'refactor', 'improve', 'optimize'
        ]
        
        # Determine mode
        if any(task in command_lower for task in quick_tasks):
            return "print"
        elif any(task in command_lower for task in file_creation_tasks):
            return "print"
        elif any(task in command_lower for task in interactive_tasks):
            return "interactive"
        else:
            return "print"
    
    def _build_claude_command(self, task: Task, execution_mode: str) -> List[str]:
        """Build Claude Code command"""
        cmd = ["claude"]
        
        # Set model if specified
        if hasattr(self, 'ai_model_config') and self.ai_model_config.get('model'):
            model = self.ai_model_config['model']
            if model in ['claude', 'claude-sonnet', 'sonnet']:
                cmd.extend(["--model", "sonnet"])
            elif model == 'opus':
                cmd.extend(["--model", "opus"])
        
        if execution_mode == "print":
            # Print mode for quick, automated tasks
            cmd.extend(["-p"])
            
            # Explicitly allow Write tool for file creation tasks
            if any(keyword in task.command.lower() for keyword in ['create', 'write', 'build', 'implement']):
                cmd.extend(["--allowedTools", "Write,Edit,MultiEdit,NotebookEdit"])
                # Add max turns to allow multiple file operations
                cmd.extend(["--max-turns", "20"])
            
            enhanced_prompt = self._build_enhanced_prompt(task)
            cmd.append(enhanced_prompt)
            
        elif execution_mode == "interactive":
            # Interactive mode
            enhanced_prompt = self._build_enhanced_prompt(task)
            cmd.append(enhanced_prompt)
        
        return cmd
    
    def _build_enhanced_prompt(self, task: Task) -> str:
        """Build prompt for Claude Code"""
        prompt_parts = []
        
        # Context header
        memory_context = f"# Agentic Agent Context: {', '.join(self.focus_areas)} specialist"
        prompt_parts.append(memory_context)
        
        # Agent identity
        prompt_parts.append(f"You are a Claude Code agent specialized in: {', '.join(self.focus_areas)}.")
        
        # Workspace context
        if hasattr(self, 'workspace_path'):
            prompt_parts.append(f"Working in project directory: {self.workspace_path}")
        
        # Add agent-specific context
        context_additions = []
        if "analysis" in self.focus_areas:
            context_additions.append("Provide detailed analysis with specific examples and code references.")
        if "debugging" in self.focus_areas:
            context_additions.append("Focus on identifying root causes and providing actionable solutions.")
        if "optimization" in self.focus_areas:
            context_additions.append("Suggest performance improvements and best practices.")
        if "code_review" in self.focus_areas:
            context_additions.append("Evaluate code quality, security, and maintainability.")
            
        if context_additions:
            prompt_parts.append("Additional context: " + " ".join(context_additions))
        
        # Main task
        prompt_parts.append(f"Task: {task.command}")
        
        # File creation instruction
        if any(keyword in task.command.lower() for keyword in ['create', 'write', 'build', 'implement']):
            prompt_parts.append("IMPORTANT: You MUST use the Write tool to create actual files. Do not just show code examples. Use Write to save each file to the filesystem. Create all necessary files including package.json, main.py, components, etc.")
        
        # Memory update instruction
        prompt_parts.append("# Please update memory with any important findings or decisions using the /memory command")
        
        return "\n\n".join(prompt_parts)
    
    def _set_environment_variables(self, env: dict) -> None:
        """Set up environment variables for Claude Code execution"""
        env.setdefault('AGENTIC_AGENT_TYPE', self.config.agent_type.value)
        env.setdefault('AGENTIC_AGENT_NAME', self.config.name)
        env.setdefault('AGENTIC_WORKSPACE', str(self.config.workspace_path))
        env.setdefault('TERM', 'xterm-256color')
        env.setdefault('PYTHONUNBUFFERED', '1')
        
        if hasattr(self, 'session_id') and self.session_id:
            env.setdefault('AGENTIC_SESSION_ID', self.session_id)
        
        self.logger.debug("Environment variables configured for Claude Code execution")
    
    async def _execute_claude_command(self, cmd: List[str], env: dict, task: Task, execution_mode: str) -> TaskResult:
        """Execute Claude Code command and handle output"""
        try:
            # Set timeout based on mode
            timeout = 1800 if execution_mode == "interactive" else 600
            
            # Use lock only for initial invocation to prevent setup wizard conflicts
            async with _claude_init_lock:
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    env=env,
                    cwd=str(self.workspace_path)
                )
            
            # Release lock immediately after process starts
            # Claude will handle its own state management from here
            
            try:
                self.logger.debug(f"Claude Code process started with PID: {process.pid}")
                
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(), 
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                return TaskResult(
                    task_id=task.id,
                    status="failed",
                    error=f"Task timed out after {timeout} seconds",
                    agent_id=self.session.id if self.session else "unknown"  
                )
            
            output = stdout.decode('utf-8', errors='replace')
            error_output = stderr.decode('utf-8', errors='replace')
            
            # Parse output
            success, parsed_output = self._parse_claude_output(
                output, error_output, process.returncode, execution_mode
            )
            
            if success:
                self.logger.info("Task completed successfully")
                return TaskResult(
                    task_id=task.id,
                    status="completed",
                    output=parsed_output,
                    agent_id=self.session.id if self.session else "unknown"
                )
            else:
                self.logger.error(f"Task failed: {parsed_output}")
                return TaskResult(
                    task_id=task.id,
                    status="failed",
                    error=parsed_output,
                    agent_id=self.session.id if self.session else "unknown"
                )
                
        except Exception as e:
            self.logger.error(f"Execution error: {e}")
            return TaskResult(
                task_id=task.id,
                status="failed",
                error=str(e),
                agent_id=self.session.id if self.session else "unknown"
            )
    
    def _parse_claude_output(self, stdout: str, stderr: str, return_code: int, execution_mode: str) -> tuple[bool, str]:
        """Parse Claude Code output"""
        
        # Check for errors
        if return_code != 0:
            error_msg = f"Command failed with exit code {return_code}"
            if stderr:
                error_msg += f"\nStderr: {stderr}"
            if stdout:
                error_msg += f"\nStdout: {stdout}"
            return False, error_msg
        
        # Handle JSON output format (print mode)
        if execution_mode == "print" and stdout.strip().startswith('{'):
            try:
                import json
                output_data = json.loads(stdout)
                
                if isinstance(output_data, dict):
                    if 'content' in output_data:
                        return True, output_data['content']
                    elif 'response' in output_data:
                        return True, output_data['response']
                    elif 'message' in output_data:
                        return True, output_data['message']
                    else:
                        return True, json.dumps(output_data, indent=2)
                else:
                    return True, str(output_data)
                    
            except json.JSONDecodeError:
                pass
        
        # Handle text output
        if stdout.strip():
            lines = stdout.split('\n')
            cleaned_lines = []
            
            for line in lines:
                if line.strip() and not line.startswith('Aider ') and not line.startswith('â”€â”€â”€'):
                    cleaned_lines.append(line.strip())
            
            if cleaned_lines:
                return True, '\n'.join(cleaned_lines)
            else:
                return True, stdout.strip()
        
        if stderr:
            return False, stderr
        else:
            return False, "No output received from Claude Code"